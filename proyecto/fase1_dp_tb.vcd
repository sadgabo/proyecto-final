$date
	Thu Nov 25 18:56:13 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module fase1_dp_tb $end
$var reg 1 ! clk $end
$scope module duv $end
$var wire 1 " c_and $end
$var wire 1 ! clk $end
$var wire 1 # c_zflag $end
$var wire 32 $ c_sum [31:0] $end
$var wire 3 % c_so [2:0] $end
$var wire 1 & c_select $end
$var wire 5 ' c_sal2 [4:0] $end
$var wire 32 ( c_result [31:0] $end
$var wire 1 ) c_regdst $end
$var wire 32 * c_mux4 [31:0] $end
$var wire 5 + c_mux2 [4:0] $end
$var wire 32 , c_mux1 [31:0] $end
$var wire 1 - c_memwrite $end
$var wire 1 . c_memreads $end
$var wire 32 / c_instruc [31:0] $end
$var wire 32 0 c_instmemOut [31:0] $end
$var wire 32 1 c_inou [31:0] $end
$var wire 1 2 c_enesc $end
$var wire 32 3 c_datolec2 [31:0] $end
$var wire 32 4 c_datolec1 [31:0] $end
$var wire 32 5 c_dataout [31:0] $end
$var wire 1 6 c_branch $end
$var wire 1 7 c_alusrc $end
$var wire 3 8 c_alop [2:0] $end
$var wire 1 9 c_ZeroFlagOut $end
$var wire 32 : c_SignOut [31:0] $end
$var wire 32 ; c_SignExtendOut [31:0] $end
$var wire 32 < c_ShiftOut [31:0] $end
$var wire 5 = c_MuxD_Out [4:0] $end
$var wire 1 > c_MuxDOut $end
$var wire 5 ? c_InstructOut2 [4:0] $end
$var wire 5 @ c_InstrctOut1 [4:0] $end
$var wire 32 A c_DatoLecout2 [31:0] $end
$var wire 32 B c_DatoLecOut1 [31:0] $end
$var wire 32 C c_DatoLec2 [31:0] $end
$var wire 32 D c_DataOut_Out [31:0] $end
$var wire 32 E c_C1 [31:0] $end
$var wire 32 F c_AluResOut2 [31:0] $end
$var wire 32 G c_AluResOut1 [31:0] $end
$var wire 32 H c_AdderOut2 [31:0] $end
$var wire 32 I c_AdderOut1 [31:0] $end
$var wire 32 J c_AddResOut3 [31:0] $end
$var wire 32 K c_AddOut [31:0] $end
$scope module Adder $end
$var wire 32 L B [31:0] $end
$var wire 32 M AddOut [31:0] $end
$var wire 32 N A [31:0] $end
$upscope $end
$scope module Aluc $end
$var wire 6 O ins [5:0] $end
$var wire 3 P uc [2:0] $end
$var reg 3 Q so [2:0] $end
$upscope $end
$scope module Banco $end
$var wire 5 R dirlec1 [4:0] $end
$var wire 5 S dirlec2 [4:0] $end
$var wire 1 2 enesc $end
$var wire 5 T diresc [4:0] $end
$var wire 32 U datoesc [31:0] $end
$var reg 32 V datolec1 [31:0] $end
$var reg 32 W datolec2 [31:0] $end
$upscope $end
$scope module MemInst $end
$var wire 32 X adr [31:0] $end
$var reg 32 Y instruccion [31:0] $end
$upscope $end
$scope module PC $end
$var wire 1 ! clk $end
$var wire 32 Z inin [31:0] $end
$var reg 32 [ inou [31:0] $end
$upscope $end
$scope module Shift $end
$var wire 32 \ ShiftOut [31:0] $end
$var wire 32 ] ShiftIn [31:0] $end
$upscope $end
$scope module SignEx $end
$var wire 16 ^ SignIn [15:0] $end
$var reg 32 _ SignOut [31:0] $end
$upscope $end
$scope module UC $end
$var wire 6 ` op [5:0] $end
$var reg 3 a alop [2:0] $end
$var reg 1 7 alusrc $end
$var reg 1 6 branch $end
$var reg 1 . memread $end
$var reg 1 & memreg $end
$var reg 1 - memwrite $end
$var reg 1 ) regdst $end
$var reg 1 2 regwrite $end
$upscope $end
$scope module alu $end
$var wire 32 b op1 [31:0] $end
$var wire 3 c sel [2:0] $end
$var wire 32 d op2 [31:0] $end
$var reg 32 e Result [31:0] $end
$var reg 1 # zflag $end
$upscope $end
$scope module bufer1 $end
$var wire 1 ! clk $end
$var wire 32 f instmem [31:0] $end
$var wire 32 g Adder [31:0] $end
$var reg 32 h AdderOut [31:0] $end
$var reg 32 i instmemOut [31:0] $end
$upscope $end
$scope module bufer2 $end
$var wire 32 j Adder [31:0] $end
$var wire 32 k InDatoLec1 [31:0] $end
$var wire 32 l InDatoLec2 [31:0] $end
$var wire 5 m InInstruc1 [4:0] $end
$var wire 5 n InInstruct2 [4:0] $end
$var wire 32 o InSignExtend [31:0] $end
$var wire 1 ! clk $end
$var reg 32 p AdderOut [31:0] $end
$var reg 32 q DatoLecOut1 [31:0] $end
$var reg 32 r DatoLecOut2 [31:0] $end
$var reg 5 s InstrctOut1 [4:0] $end
$var reg 5 t InstructOut2 [4:0] $end
$var reg 32 u SignExtendOut [31:0] $end
$upscope $end
$scope module bufer3 $end
$var wire 32 v InAddRes [31:0] $end
$var wire 32 w InAluRes [31:0] $end
$var wire 32 x InDatoLec2 [31:0] $end
$var wire 1 # InZeroFlag $end
$var wire 1 ! clk $end
$var wire 5 y InMuxD [4:0] $end
$var reg 32 z AddResOut [31:0] $end
$var reg 32 { AluResOut1 [31:0] $end
$var reg 32 | DatoLec2 [31:0] $end
$var reg 5 } MuxDOut [4:0] $end
$var reg 1 9 ZeroFlagOut $end
$upscope $end
$scope module bufer4 $end
$var wire 32 ~ InAluRes [31:0] $end
$var wire 1 ! clk $end
$var wire 1 > InMuxD $end
$var wire 32 !" InDataOut [31:0] $end
$var reg 32 "" AluResOut2 [31:0] $end
$var reg 32 #" DataOut_Out [31:0] $end
$var reg 1 > MuxD_Out $end
$upscope $end
$scope module ins6 $end
$var wire 32 $" o2 [31:0] $end
$var wire 1 & sell $end
$var wire 32 %" o1 [31:0] $end
$var reg 32 &" sal [31:0] $end
$upscope $end
$scope module ins7 $end
$var wire 5 '" o3 [4:0] $end
$var wire 5 (" o4 [4:0] $end
$var wire 1 ) selec $end
$var reg 5 )" sal2 [4:0] $end
$upscope $end
$scope module ins9 $end
$var wire 32 *" o5 [31:0] $end
$var wire 32 +" o6 [31:0] $end
$var wire 1 7 select3 $end
$var reg 32 ," sal3 [31:0] $end
$upscope $end
$scope module memoria $end
$var wire 32 -" datain [31:0] $end
$var wire 32 ." dir [31:0] $end
$var wire 1 . memreads $end
$var wire 1 - memwrites $end
$var reg 32 /" dataout [31:0] $end
$upscope $end
$scope module muxE $end
$var wire 5 0" instruc1 [4:0] $end
$var wire 5 1" instruc2 [4:0] $end
$var wire 1 ) selec $end
$var reg 5 2" sal2 [4:0] $end
$upscope $end
$scope module muxf $end
$var wire 32 3" B1 [31:0] $end
$var wire 1 " sel1 $end
$var wire 32 4" A1 [31:0] $end
$var reg 32 5" C1 [31:0] $end
$upscope $end
$scope module sumador $end
$var wire 32 6" E [31:0] $end
$var wire 32 7" Sum [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 7"
b0 6"
b100 5"
b100 4"
b0 3"
b0 2"
b0 1"
b0 0"
bx /"
bx ."
b1000 -"
bz ,"
bz +"
b1000 *"
b0 )"
b0 ("
b1000 '"
bx &"
bx %"
bx $"
b0 #"
b0 ""
bx !"
bx ~
b0 }
b0 |
b0 {
b0 z
b0 y
b1000 x
bx w
b101100 v
b0 u
b0 t
b0 s
b0 r
b0 q
b0 p
b1010 o
b0 n
b1000 m
b1000 l
bx k
b0 j
b0 i
b0 h
b100 g
b100000000010000000000000001010 f
bx e
bz d
b0 c
bx b
b0 a
b1000 `
b1010 _
b1010 ^
b1010 ]
b101000 \
b0 [
b100 Z
b100000000010000000000000001010 Y
b0 X
b1000 W
bx V
bx U
b0 T
b1000 S
b0 R
b0 Q
b0 P
b1010 O
b100 N
b101100 M
b101000 L
b101100 K
b0 J
b0 I
b0 H
b0 G
b0 F
b100 E
b0 D
b0 C
b0 B
b0 A
b0 @
b0 ?
0>
b0 =
b101000 <
b0 ;
b1010 :
09
b0 8
17
06
bx 5
bx 4
b1000 3
12
b0 1
b0 0
b100000000010000000000000001010 /
0.
0-
bx ,
b0 +
bz *
0)
bx (
b0 '
0&
b0 %
b100 $
x#
0"
0!
$end
#50
bx 3
bx W
bx l
bx x
bx *"
bx -"
b0 <
b0 L
b0 \
bx *
bx d
bx ,"
b1000 '
b1000 y
b1000 2"
b0 :
b0 ]
b0 _
b0 o
b111 8
b111 P
b111 a
07
1)
b0 O
b0 m
b0 ^
b0 '"
b0 S
b0 `
b0 /
b0 Y
b0 f
b1000 E
b1000 Z
b1000 5"
b1000 K
b1000 M
b1000 v
b1000 $
b1000 N
b1000 g
b1000 4"
b1000 7"
b100 1
b100 X
b100 [
b100 6"
b100000000010000000000000001010 0
b100000000010000000000000001010 i
b100 I
b100 h
b100 j
b1000 @
b1000 s
b1000 0"
b1010 ;
b1010 u
b1000 A
b1000 r
bx B
bx q
b1000 C
b1000 |
bx G
bx {
x9
b101100 J
b101100 z
b101100 3"
bx F
bx ""
bx D
bx #"
1!
#100
